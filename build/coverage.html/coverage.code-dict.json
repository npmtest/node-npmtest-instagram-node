{"/home/travis/build/npmtest/node-npmtest-instagram-node/test.js":"/* istanbul instrument in package npmtest_instagram_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-instagram-node/lib.npmtest_instagram_node.js":"/* istanbul instrument in package npmtest_instagram_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_instagram_node = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_instagram_node = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-instagram-node/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-instagram-node && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_instagram_node */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_instagram_node\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_instagram_node.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_instagram_node.rollup.js'] =\n            local.assetsDict['/assets.npmtest_instagram_node.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_instagram_node.__dirname +\n                    '/lib.npmtest_instagram_node.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-instagram-node/instagram-node/lib/instagram.js":"// Copyright Teleportd Ltd. and other Contributors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar fwk = require('fwk');\nvar http = require('http');\nvar https = require('https');\nvar query = require('querystring');\nvar url = require('url');\nvar crypto = require('crypto');\n\n/**\n * Instagram API driver for NodeJS\n * Proceeds the call to the API and give\n * back the response\n *\n * @param spec { agent, host, port }\n */\nvar instagram = function(spec, my) {\n  var _super = {};\n  my = my || {};\n  spec = spec || {};\n\n  my.limit = null;\n  my.remaining = null;\n  my.agent = spec.agent;\n  my.host = spec.host || 'https://api.instagram.com';\n  my.port = spec.port || 443;\n  my.enforce_signed_requests = spec.enforce_signed_requests || false;\n\n  // public\n  var use;                              /* use(spec);                                       */\n\n  var user;                             /* user(user_id, cb);                               */\n  var user_self_feed;                   /* user_self_feed(options, cb);                     */\n  var user_media_recent;                /* user_media_recent(user_id, options, cb);         */\n  var user_self_media_recent;           /* user_self_media_recent(options, cb);             */\n  var user_self_liked;                  /* user_self_liked(options, cb);                    */\n  var user_search;                      /* user_search(query, options, cb);                 */\n\n  var user_follows;                     /* user_follows(user_id, cb);                       */\n  var user_followers;                   /* user_followers(user_id, cb);                     */\n  var user_self_requested_by;           /* user_self_requested_by(cb);                      */\n  var user_relationship;                /* user_relationship(user_id, cb);                  */\n  var set_user_relationship;            /* set_user_relationship(user_id, action, cb);      */\n\n  var media;                            /* media(media_id, cb);                             */\n  var media_shortcode;                  /* media_shortcode(media_shortcode, cb);            */\n  var media_search;                     /* media_search(lat, lng, options, cb);             */\n  var media_popular;                    /* media_popular(cb);                               */\n\n  var comments;                         /* comments(media_id, cb);                          */\n  var add_comment;                      /* add_comment(media_id, text, cb);                 */\n  var del_comment;                      /* del_comment(media_id, comment_id, cb);           */\n\n  var likes;                            /* likes(media_id, cb);                             */\n  var add_like;                         /* add_like(media_id, cb);                          */\n  var del_like;                         /* del_like(media_id, cb);                          */\n\n  var tag;                              /* tag(tag, cb);                                    */\n  var tag_media_recent;                 /* tag_media_recent(tag, options, cb);              */\n  var tag_search;                       /* tag_search(query, cb);                           */\n\n  var location;                         /* location(location_id, cb);                       */\n  var location_media_recent;            /* location_media_recent(location_id, options, cb); */\n  var location_search;                  /* location_search(spec, options, cb);              */\n\n  var geography_media_recent;           /* geography_media_recent(id, options, cb);         */\n\n  var subscriptions;                    /* subscriptions(cb);                               */\n  var del_subscription;                 /* del_subscription(options, cb);                   */\n  var add_tag_subscription;             /* add_tag_subscription(tag, cb_url, cb);           */\n  var add_geography_subscription;       /* add_geography_subscription(lat, lng, radius, cb_url, cb); */\n  var add_user_subscription;            /* add_user_subscription(cb_url, cb);               */\n  var add_location_subscription;        /* add_location_subscription(id, cb_url, cb);       */\n\n  var get_authorization_url;            /* get_authorization_url(redirect_uri, permissions);*/\n  var authorize_user;                   /* authorize_user(code, redirect_uri, cb);          */\n\n  var oembed;                           /* oembed(url, cb);                             */\n\n  // private\n  var call;                             /* call(method, path, params, cb, retry);           */\n  var handle_error;                     /* handle_error(body, cb, retry);                   */\n  var sign_request;                     /* sign_request(endpoint, params, client_secret);   */\n  var sort_object;                      /* sort_object(params);                             */\n\n  var that = {};\n\n  /*******************************/\n  /*       Private helpers       */\n  /*******************************/\n\n  /**\n   * Make a call on instagram API with the given params, path & method\n   * @param method string the request method\n   * @param path string the path\n   * @param params object the params\n   * @param cb function (err, result, remaining, limit);\n   * @param retry function a retry function\n   */\n  call = function(method, path, params, cb, retry) {\n    if(my.auth) {\n\n      // we don't need auth parameters if we're hitting the oembed endpoint\n      if (path.search('oembed') < 0) {\n        for(var opt in my.auth) {\n          if(my.auth.hasOwnProperty(opt)) {\n            params[opt] = my.auth[opt];\n          }\n        }\n      }\n\n      // Signature parameter\n      if(params.sign_request || my.enforce_signed_requests) {\n        try {\n          var client_secret;\n\n          if (params.sign_request) {\n            client_secret = params.sign_request.client_secret;\n            delete params.sign_request;\n          } else {\n            client_secret = my.auth.client_secret;\n          }\n\n          params['sig'] = sign_request(\n            path,\n            params,\n            client_secret\n          );\n        }\n        catch(err) {\n          return handle_error(err, cb, retry);\n        }\n      }\n\n      var options = {\n        host: url.parse(my.host).hostname,\n        port: my.port,\n        method: method,\n        path: '/v1' + path + (method === 'GET' || method === 'DELETE' ? '?' + query.stringify(params) : ''),\n        agent: my.agent,\n        headers: {}\n      };\n\n      // oauth and oembed calls don't use /v1\n      if (path.search('oauth') >= 0 || path.search('oembed') >= 0) {\n        options.path = options.path.substring(3); // chop off '/v1'\n      }\n\n      var data = null;\n\n      if (method !== 'GET' && method !== 'DELETE') {\n        data = query.stringify(params);\n        options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n        options.headers['Content-Length'] = data.length;\n      }\n\n      var req = https.request(options, function(res) {\n        var body = '';\n        res.setEncoding('utf8');\n\n        res.on('data', function(chunk) {\n          body += chunk;\n        });\n\n        res.on('end', function() {\n          var result;\n          var limit = parseInt(res.headers['x-ratelimit-limit'], 10) || 0;\n          var remaining = parseInt(res.headers['x-ratelimit-remaining'], 10) || 0;\n          my.limit = limit;\n          my.remaining = remaining;\n\n          try {\n            result = JSON.parse(body);\n          } catch(err) {\n            return handle_error(err, cb, retry, res.statusCode, body);\n          }\n\n          return cb(null, result, remaining, limit);\n        });\n      });\n\n      req.on('error', function(err) {\n        return handle_error(err, cb, retry);\n      });\n\n      if (data !== null) {\n        req.write(data);\n      }\n\n      req.end();\n\n    } else {\n      return handle_error(new Error('Must be authentified'), cb, retry);\n    }\n  };\n\n  /**\n   * Handle API errors\n   * @param body object the response from instagram API\n   * @param cb function (err);\n   * @param retry function can be called to retry\n   * @param status number the status code [opt]\n   * @param bdy  string  the body received from instagram [opt]\n   * Error objects can have\n   *   - status_code status code [opt]\n   *   - body body received      [opt]\n   *   - error_type error type from instagram\n   *   - error_message error message from instagram\n   *   - code if error comes from instagram\n   *   - retry a function that can be called to retry\n   *           with same params\n   */\n  handle_error = function(body, cb, retry, status, bdy) {\n    if(body && ((body.meta && body.meta.error_type) || body.error_type)) {\n      // if body is an instagram error\n      if(!body.meta) {\n        body.meta = {\n          code: body.code,\n          error_type: body.error_type,\n          error_message: body.error_message\n        };\n      }\n      var error = new Error(body.meta.error_type + ': ' + body.meta.error_message);\n      error.code = body.meta.code;\n      error.error_type = body.meta.error_type;\n      error.error_message = body.meta.error_message;\n      error.retry = retry;\n      return cb(error);\n    } else if(body && body.message && body.stack) {\n      // if body is an error\n      body.retry = retry;\n      if(status)\n        body.status_code = status;\n      if(bdy)\n        body.body = bdy;\n      return cb(body);\n    } else {\n      var error = new Error('Unknown error');\n      error.retry = retry;\n      return cb(error);\n    }\n  };\n\n  /**\n   * Sign the request using new instagram sign rules.\n   * We are merging endpoint, params and client_secret and hashing all together\n   * @param endpoint string api endpoint to call\n   * @param params object api call params to be hashed\n   * @param client_secret string the client secret to sign the request\n   * @throws Error if arguments are not correct\n   */\n  sign_request = function(endpoint, params, client_secret) {\n    if(typeof client_secret !== 'string') {\n      throw new Error('Wrong param \"client_secret\"');\n    }\n\n    var sig = endpoint;\n\n    params = sort_object(params);\n    for (var key in params){\n      if (params.hasOwnProperty(key)) {\n        sig += \"|\"+key+\"=\"+params[key];\n      }\n    }\n\n    var hmac = crypto.createHmac('sha256', client_secret);\n    hmac.update(sig);\n    return hmac.digest('hex');\n  };\n\n  /**\n   * Sort onject function.\n   * We need to sort params that being added to api call.\n   * @param object\n   * @returns {Object}\n   */\n  sort_object = function(object) {\n    var keys = Object.keys(object),\n      i, len = keys.length;\n\n    keys.sort();\n    var newobj = new Object;\n    for (i = 0; i < len; i++)\n    {\n      k = keys[i];\n      newobj[k] = object[keys[i]];\n    }\n    return newobj;\n  };\n\n  /*****************************/\n  /*      Public functions     */\n  /*****************************/\n\n  /**\n   * Use the specified options to sign requests: can be an access_key\n   * or a client_id/client_secret keys pair\n   * @param options object { access_key } ||\n   *                       { client_id, client_secret }\n   * @throws Error if options is wrong\n   */\n  use = function(options) {\n    if(typeof options === 'object') {\n      if (typeof options.enforce_signed_requests != 'undefined') {\n        my.enforce_signed_requests = options.enforce_signed_requests;\n      }\n      if(options.access_token) {\n        my.limit = null;\n        my.remaining = null;\n        my.auth = {\n          access_token: options.access_token\n        };\n        if (options.client_secret) {\n          my.auth.client_secret = options.client_secret;\n        }\n      } else if(options.client_id && options.client_secret) {\n        my.limit = null;\n        my.remaining = null;\n        my.auth = {\n          client_id: options.client_id,\n          client_secret: options.client_secret\n        };\n      } else {\n        throw new Error('Wrong param \"options\"');\n      }\n    } else {\n      throw new Error('Wrong param \"options\"');\n    }\n  };\n\n  /**\n   * Retrieves information about the given user\n   * @param id string the user id\n   * @param cb function (err, user, remaining, limit);\n   */\n  user = function(id, cb) {\n    var retry = function() {\n      user(id, cb);\n    };\n\n    if(typeof id !== 'string' || id === '') {\n      return handle_error(new Error('Wrong param \"id\"'), cb, retry);\n    }\n\n    call('GET', '/users/' + id, {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves the current user feed\n   * @param options object { count,  [opt]\n   *                         min_id, [opt]\n   *                         max_id  [opt] }\n   * @param cb function (err, feed, pagination, remaining, limit);\n   */\n  user_self_feed = function(options, cb) {\n    var retry = function() {\n      user_self_feed(options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(options.count) {\n      params.count = options.count;\n    }\n    if(options.min_id) {\n      params.min_id = options.min_id;\n    }\n    if(options.max_id) {\n      params.max_id = options.max_id;\n    }\n\n    call('GET', '/users/self/feed', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_max_id) {\n          options = fwk.shallow(options);\n          options.max_id = result.pagination.next_max_id;\n          var next = function(cb) {\n            user_self_feed(options, cb);\n          };\n          result.pagination.next = next;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves the current user likes\n   * @param options object { count,        [opt]\n   *                         max_like_id   [opt] }\n   * @param cb function (err, likes, pagination, remaining, limit);\n   */\n  user_self_liked = function(options, cb) {\n    var retry = function() {\n      user_self_liked(options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(options.count) {\n      params.count = options.count;\n    }\n    if(options.max_like_id) {\n      params.max_like_id = options.max_like_id;\n    }\n\n    call('GET', '/users/self/media/liked', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_max_like_id) {\n          options = fwk.shallow(options);\n          options.max_like_id = result.pagination.next_max_like_id;\n          var next = function(cb) {\n            user_self_liked(options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n\n  /**\n   * Get the most recent media published by a user\n   * @param user_id string the user id\n   * @param options object { count,           [opt]\n   *                         max_timestamp,   [opt]\n   *                         min_timestamp,   [opt]\n   *                         max_id,          [opt]\n   *                         min_id           [opt] }\n   * @param cb(err, results, pagination, remaining, limit);\n   */\n  user_media_recent = function(user_id, options, cb) {\n    var retry = function() {\n      user_media_recent(user_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof user_id !== 'string' || user_id === '') {\n      return handle_error(new Error('Wrong param \"user_id\"'), cb, retry);\n    }\n\n    if(options.count) {\n      params.count = options.count;\n    }\n    if(options.max_timestamp) {\n      params.max_timestamp = options.max_timestamp;\n    }\n    if(options.min_timestamp) {\n      params.min_timestamp = options.min_timestamp;\n    }\n    if(options.max_id) {\n      params.max_id = options.max_id;\n    }\n    if(options.min_id) {\n      params.min_id = options.min_id;\n    }\n\n    call('GET', '/users/' + user_id + '/media/recent', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_max_id) {\n          options = fwk.shallow(options);\n          options.max_id = result.pagination.next_max_id;\n          var next = function(cb) {\n            user_media_recent(user_id, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get the most recent media published by the user being authenticated\n   * @param options object { count,           [opt]\n   *                         max_timestamp,   [opt]\n   *                         min_timestamp,   [opt]\n   *                         max_id,          [opt]\n   *                         min_id           [opt] }\n   * @param cb(err, results, pagination, remaining, limit);\n   */\n  user_self_media_recent = function(options, cb) {\n    var retry = function() {\n      user_self_media_recent(options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if(typeof my.auth.access_token !== 'string') {\n      return handle_error(new Error('You must first set an `access_token` with `use()`'), cb, retry);\n    }\n\n    var user_id = my.auth.access_token.split('.')[0];\n    return user_media_recent(user_id, options, cb);\n  };\n\n  /**\n   * Search for a user according to the given query\n   * @param query string the name to search for\n   * @param options object { count [opt] }\n   * @param cb function (err, users, limit);\n   */\n  user_search = function(query, options, cb) {\n    var retry = function() {\n      user_search(query, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof query !== 'string' || query === '') {\n      return handle_error(new Error('Wrong param \"query\": ' + query), cb, retry);\n    }\n    params.q = query;\n\n    if(options.count) {\n      params.count = options.count;\n    }\n\n    call('GET', '/users/search', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves the list of users the given user follows\n   * @param user_id string the user to check\n   * @param options object { count, [opt]\n   *                         cursor [opt] }\n   * @param cb function (err, users, pagination, remaining, limit);\n   */\n  user_follows = function(user_id, options, cb) {\n    var retry = function() {\n      user_follows(user_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if(typeof user_id !== 'string' || user_id === '') {\n      return handle_error(new Error('Wrong param \"user_id\"'), cb, retry);\n    }\n\n    var params = {};\n    if(options.count) {\n      params.count = options.count;\n    }\n    if(options.cursor) {\n      params.cursor = options.cursor;\n    }\n\n    call('GET', '/users/' + user_id + '/follows', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_cursor) {\n          options = fwk.shallow(options);\n          options.cursor = result.pagination.next_cursor;\n          var next = function(cb) {\n            user_follows(user_id, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves the list of users the given user is followed by\n   * @param user_id string the user to check\n   * @param options object { count, [opt]\n   *                         cursor [opt] }\n   * @param cb function (err, users, pagination, remaining, limit);\n   */\n  user_followers = function(user_id, options, cb) {\n    var retry = function() {\n      user_followers(user_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if(typeof user_id !== 'string' || user_id === '') {\n      return handle_error(new Error('Wrong param \"user_id\"'), cb, retry);\n    }\n\n    var params = {};\n    if(options.count) {\n      params.count = options.count;\n    }\n    if(options.cursor) {\n      params.cursor = options.cursor;\n    }\n\n    call('GET', '/users/' + user_id + '/followed-by', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_cursor) {\n          options = fwk.shallow(options);\n          options.cursor = result.pagination.next_cursor;\n          var next = function(cb) {\n            user_followers(user_id, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves the list of users who have requested the current users's\n   * permission to follow\n   * @param cb function (err, users, limit);\n   */\n  user_self_requested_by = function(cb) {\n    var retry = function() {\n      user_self_requested_by(cb);\n    };\n\n    call('GET', '/users/self/requested-by', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get information about a relationship to another user\n   * @param user_id string the user to check\n   * @param cb function (err, result, limit);\n   */\n  user_relationship = function(user_id, cb) {\n    var retry = function() {\n      user_relationship(user_id, cb);\n    };\n\n    if(typeof user_id !== 'string' || user_id === '') {\n      return handle_error(new Error('Wrong param \"user_id\"'), cb, retry);\n    }\n\n    call('GET', '/users/' + user_id + '/relationship', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Modify the relationship between current user and the target user\n   * @param user_id string the target user\n   * @param action string 'follow' || 'unfollow' || 'block' || 'unblock' || 'approve' || 'ignore'\n   * @param options object { sign_request: {\n   *                           client_secret: 'xxx'\n   *                       }}\n   * @param cb function (err, result, limit);\n   */\n  set_user_relationship = function(user_id, action, options, cb) {\n    var retry = function() {\n      set_user_relationship(user_id, action, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof user_id !== 'string' || user_id === '') {\n      return handle_error(new Error('Wrong param \"user_id\"'), cb, retry);\n    }\n\n    if(['follow', 'unfollow', 'block', 'unblock', 'approve', 'ignore'].indexOf(action.toLowerCase()) === -1) {\n      return handle_error(new Error('Wrong param \"action\"'), cb);\n    }\n    params.action = action.toLowerCase();\n\n    if(options.sign_request) {\n      params.sign_request = options.sign_request;\n    }\n\n    call('POST', '/users/' + user_id + '/relationship', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves information about a given media\n   * @param media_id string the id of the media\n   * @param cb function (err, result, limit);\n   */\n  media = function(media_id, cb) {\n    var retry = function() {\n      media(media_id, cb);\n    };\n\n    if(typeof media_id !== 'string' || media_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\"'), cb, retry);\n    }\n\n    call('GET', '/media/' + media_id, {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves information about a media with given shortcode\n   * @param media_shortcode string the shortcode of the media\n   * For media http://instagram.com/p/ABC/ shortcode is ABC\n   * @param cb function (err, result, limit);\n   */\n  media_shortcode = function(media_shortcode, cb) {\n      var retry = function() {\n          media_shortcode(media_shortcode, cb);\n      };\n\n      if(typeof media_shortcode !== 'string' || media_shortcode === '') {\n          return handle_error(new Error('Wrong param \"media_shortcode\"'), cb, retry);\n      }\n\n      call('GET', '/media/shortcode/' + media_shortcode, {}, function(err, result, remaining, limit) {\n          if(err) {\n              return handle_error(err, cb, retry);\n          } else if(result && result.meta && result.meta.code === 200) {\n              return cb(null, result.data, remaining, limit);\n          } else {\n              return handle_error(result, cb, retry);\n          }\n      }, retry);\n  };\n\n  /**\n   * Search for media in a given area\n   * @param lat number the latitude\n   * @param lng number the longitude\n   * @param options object { min_timestamp,    [opt]\n   *                         max_timestamp,    [opt]\n   *                         distance          [opt] }\n   * @param cb function (err, result, limit);\n   */\n  media_search = function(lat, lng, options, cb) {\n    var retry = function() {\n      media_search(lat, lng, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof lat !== 'number' || typeof lng !== 'number') {\n      return handle_error(new Error('Wrong params \"lat\" & \"lng\"'), cb, retry);\n    }\n\n    params.lat = lat;\n    params.lng = lng;\n\n    if(options.max_timestamp) {\n      if(options.max_timestamp > parseInt(Date.now() / 1000, 10)) {\n        options.max_timestamp = parseInt(Date.now() / 1000, 10);\n      }\n      params.max_timestamp = options.max_timestamp;\n    }\n    if(options.min_timestamp) {\n      if(options.min_timestamp > parseInt(Date.now() / 1000, 10)) {\n        options.min_timestamp = parseInt(Date.now() / 1000, 10);\n      }\n      params.min_timestamp = options.min_timestamp;\n    }\n    if(options.distance) {\n      params.distance = options.distance;\n    }\n    if(options.count) {\n      params.count = options.count;\n    }\n\n    call('GET', '/media/search', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves a list of most popular media at the moment\n   * @param cb function (err, result, limit);\n   */\n  media_popular = function(cb) {\n    var retry = function() {\n      media_popular(cb);\n    };\n\n    call('GET', '/media/popular', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves all the comments for the given media\n   * @param media_id string the media id\n   * @param cb function (err, result, limit);\n   */\n  comments = function(media_id, cb) {\n    var retry = function() {\n      comments(media_id, cb);\n    };\n\n    if(typeof media_id !== 'string' || media_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\"'), cb, retry);\n    }\n\n    call('GET', '/media/' + media_id + '/comments', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Add a comment on the given media\n   * @param media_id string the media id\n   * @param text string the text to post\n   * @param options object { sign_request: {\n   *                           client_secret: 'xxx'\n   *                       }}\n   * @param cb function (err, limit);\n   */\n  add_comment = function(media_id, text, options, cb) {\n    var retry = function() {\n      add_comment(media_id, text, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof media_id !== 'string' || media_id === '' ||\n       typeof text !== 'string' || text === '') {\n      return handle_error(new Error('Wrong param \"media_id\" or \"text\"'), cb, retry);\n    }\n    params.text = text;\n\n    if(options.sign_request) {\n      params.sign_request = options.sign_request;\n    }\n\n    call('POST', '/media/' + media_id + '/comments', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Delete the given comment from the given media\n   * @param media_id string the media id\n   * @param comment_id string the comment id\n   * @param options object { sign_request: {\n   *                           client_secret: 'xxx'\n   *                       }}\n   * @param cb function (err, limit);\n   */\n  del_comment = function(media_id, comment_id, options, cb) {\n    var retry = function() {\n      del_comment(media_id, comment_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof media_id !== 'string' || media_id === '' ||\n       typeof comment_id !== 'string' || comment_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\" or \"comment_id\"'), cb, retry);\n    }\n\n    if(options.sign_request) {\n      params.sign_request = options.sign_request;\n    }\n\n    call('DELETE', '/media/' + media_id + '/comments/' + comment_id, params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves all the likes for the given media\n   * @param media_id string the media id\n   * @param cb function (err, result, limit);\n   */\n  likes = function(media_id, cb) {\n    var retry = function() {\n      likes(media_id, cb);\n    };\n\n    if(typeof media_id !== 'string' || media_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\"'), cb, retry);\n    }\n\n    call('GET', '/media/' + media_id + '/likes', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Add a like on the given media\n   * @param media_id string the media id\n   * @param options object { sign_request: {\n   *                           client_secret: 'xxx'\n   *                       }}\n   * @param cb function (err, limit);\n   */\n  add_like = function(media_id, options, cb) {\n    var retry = function() {\n      add_like(media_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof media_id !== 'string' || media_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\"'), cb, retry);\n    }\n\n    if(options.sign_request) {\n      params.sign_request = options.sign_request;\n    }\n\n    call('POST', '/media/' + media_id + '/likes', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Delete the like from the given media\n   * @param media_id string the media id\n   * @param options object { sign_request: {\n   *                           client_secret: 'xxx'\n   *                       }}\n   * @param cb function (err, limit);\n   */\n  del_like = function(media_id, options, cb) {\n    var retry = function() {\n      del_like(media_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof media_id !== 'string' || media_id === '') {\n      return handle_error(new Error('Wrong param \"media_id\"'), cb, retry);\n    }\n\n    if(options.sign_request) {\n      params.sign_request = options.sign_request\n    }\n\n    call('DELETE', '/media/' + media_id + '/likes', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves information about a tag\n   * @param _tag string the tag\n   * @param cb function (err, result, limit);\n   */\n  tag = function(_tag, cb) {\n    var retry = function() {\n      tag(_tag, cb);\n    };\n\n    if(typeof _tag !== 'string' || _tag === '') {\n      return handle_error(new Error('Wrong param \"tag\"'), cb, retry);\n    }\n\n    call('GET', '/tags/' + encodeURIComponent(_tag), {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get recent medias for the given tag\n   * @param tag string the tag\n   * @param options object { min_id,     [opt]\n   *                         max_id      [opt] }\n   * @param cb function (err, result, pagination, remaining, limit);\n   */\n  tag_media_recent = function(tag, options, cb) {\n    var retry = function() {\n      tag_media_recent(tag, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof tag !== 'string' || tag === '') {\n      return handle_error(new Error('Wrong param \"tag\"'), cb, retry);\n    }\n\n    if(options.min_id || options.min_tag_id) {\n      params.min_tag_id = options.min_id || options.min_tag_id;\n    }\n    if(options.max_id || options.max_tag_id) {\n      params.max_tag_id = options.max_id || options.max_tag_id;\n    }\n    if(options.count) {\n      params.count = options.count;\n    }\n\n    call('GET', '/tags/' + encodeURIComponent(tag) + '/media/recent', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_max_tag_id) {\n          options = fwk.shallow(options);\n          // Syntax weirdness coming from IG API (max_tag_id instead of max_id)\n          // [see http://instagram.com/developer/endpoints/tags/]\n          options.max_tag_id = result.pagination.next_max_tag_id;\n          var next = function(cb) {\n            tag_media_recent(tag, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Search for tags by name\n   * @param query string the search to perform\n   * @param cb function (err, result, limit);\n   */\n  tag_search = function(query, cb) {\n    var retry = function() {\n      tag_search(query, cb);\n    };\n\n    if(typeof query !== 'string' || query === '') {\n      return handle_error(new Error('Wrong param \"query\"'), cb, retry);\n    }\n\n    call('GET', '/tags/search', { q: query }, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n\n  /**\n   * Retrieves information about a location\n   * @param location_id string the location id\n   * @param cb function (err, result, limit);\n   */\n  location = function(location_id, cb) {\n    var retry = function() {\n      location(location_id, cb);\n    };\n\n    if(typeof location_id !== 'string' || location_id === '') {\n      return handle_error(new Error('Wrong param \"location_id\"'), cb, retry);\n    }\n\n    call('GET', '/locations/' + location_id, {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get recent medias for the given location\n   * @param location_id string the location id\n   * @param options object { min_id,          [opt]\n   *                         max_id,          [opt]\n   *                         min_timestamp,   [opt]\n   *                         max_timestamp    [opt] }\n   * @param cb function (err, result, pagination, remaining, limit);\n   */\n  location_media_recent = function(location_id, options, cb) {\n    var retry = function() {\n      location_media_recent(location_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if(typeof location_id !== 'string' || location_id === '') {\n      return handle_error(new Error('Wrong param \"location_id\"'), cb, retry);\n    }\n\n    var params = {};\n    if(options.min_id) {\n      params.min_id = options.min_id;\n    }\n    if(options.max_id) {\n      params.max_id = options.max_id;\n    }\n    if(options.min_timestamp) {\n      params.min_timestamp = options.min_timestamp;\n    }\n    if(options.max_timestamp) {\n      params.max_timestamp = options.max_timestamp;\n    }\n\n    call('GET', '/locations/' + location_id + '/media/recent', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_max_id) {\n          options = fwk.shallow(options);\n          options.max_id = result.pagination.next_max_id;\n          var next = function(cb) {\n            location_media_recent(location_id, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Search for locations by lat/lng\n   * @param spec object { lat, lng } ||\n   *                    { foursquare_v2_id } ||\n   *                    { foursquare_id } ||\n   *                    { facebook_places_id }\n   * @param options object { distance [opt] }\n   * @param cb function (err, result, limit);\n   */\n  location_search = function(spec, options, cb) {\n    var retry = function() {\n      location_search(spec, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(options.distance) {\n      params.distance = options.distance;\n    }\n\n    if(typeof spec.lat === 'number' && typeof spec.lng === 'number') {\n      params.lat = spec.lat;\n      params.lng = spec.lng;\n    } else if(spec.foursquare_v2_id) {\n      params.foursquare_v2_id = spec.foursquare_v2_id;\n    } else if(spec.foursquare_id) {\n      params.foursquare_id = spec.foursquare_id;\n    } else if(spec.facebook_places_id) {\n      params.facebook_places_id = spec.facebook_places_id;\n    } else {\n      return handle_error(new Error('Wrong param \"lat/lng\" or \"foursquare(_v2)_id\" or \"facebook_places_id\"'), cb, retry);\n    }\n\n    call('GET', '/locations/search', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get recent medias for the given geography\n   * @param geo_id string the instagram geography id\n   * @param options object { min_id,          [opt]\n   *                         count            [opt] }\n   * @param cb function (err, result, pagination, remaining, limit);\n   */\n  geography_media_recent = function(geography_id, options, cb) {\n    var retry = function() {\n      geography_media_recent(geography_id, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if(typeof geography_id !== 'string' || geography_id === '') {\n      return handle_error(new Error('Wrong param \"geography_id\"'), cb, retry);\n    }\n\n    var params = {};\n    if(options.min_id) {\n      params.min_id = options.min_id;\n    }\n    if(options.count) {\n      params.count = options.count;\n    }\n\n    call('GET', '/geographies/' + geography_id + '/media/recent', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        if(result.pagination && result.pagination.next_min_id) {\n          options = fwk.shallow(options);\n          options.min_id = result.pagination.next_min_id;\n          var next = function(cb) {\n            geography_media_recent(geography_id, options, cb);\n          };\n          result.pagination.next = next;\n          delete result.pagination.next_url;\n        }\n\n        return cb(null, result.data, result.pagination || {}, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieve authentication URL for user.\n   * @param redirect_uri string the url to redirect to\n   * @param options object { scope, [opt] array ['likes', 'comments', 'relationships']\n   *                         state  [opt] string}\n   * @return url string the formated url\n   * @throw err if client_id/client_secret are not set.\n   */\n  get_authorization_url = function(redirect_uri, options) {\n    var options = options || {};\n    var url_obj = url.parse(my.host);\n    url_obj.pathname = '/oauth/authorize';\n\n    if(!my.auth.client_id || !my.auth.client_secret) {\n      throw new Error('Please supply client_id and client_secret via use()');\n    }\n\n    var params = {\n      client_id: my.auth.client_id,\n      redirect_uri: redirect_uri,\n      response_type: 'code'\n    };\n\n    if(options.state) {\n      params.state = options.state;\n    }\n\n    url_obj.query = params;\n\n    var auth_url = url.format(url_obj);\n\n    if(Array.isArray(options.scope)) {\n      auth_url += '&scope=' + options.scope.join('+');\n    }\n\n    return auth_url;\n  };\n\n  /**\n   * Authorizes a user and returns the response from the server.\n   * This is the final leg in instagram's authentication process.\n   * Note this function also sets and uses the access token that\n   * was retrieved via authentication.\n   * @param code string the code received from instagram\n   *    Passed as a get parameter to a redirect uri once a user has\n   *    authenticated via Instagram. See Instagram's Authorization\n   *    API documentation for more information\n   * @param redirect_uri string the url to redirect to\n   * @param cb function (err, result);\n   */\n  authorize_user = function(code, redirect_uri, cb) {\n    var retry = function() {\n      authorize_user(code, redirect_uri, cb);\n    };\n\n    var params = {\n      client_id: my.auth.client_id,\n      client_secret: my.auth.client_secret,\n      grant_type: 'authorization_code',\n      redirect_uri: redirect_uri,\n      code: code\n    };\n\n    call('POST', '/oauth/access_token', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      }\n      else if(result && result.access_token) {\n        return cb(null, result);\n      }\n      else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Retrieves information about a given media based on its url (see http://instagram.com/developer/embedding/)\n   * @param url string the url of the instagram media item to get the oEmbed data for\n   * @param options object { callback,     [opt]\n   *                         omitscript,   [opt]\n   *                         hidecaption,  [opt]\n   *                         maxwidth      [opt] }\n   * @param cb function (err, result, limit);\n   */\n  oembed = function(url, options, cb) {\n    var retry = function() {\n      oembed(url, options, cb);\n    }\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    var params = {};\n\n    if(typeof url !== 'string' || url === '') {\n      return handle_error(new Error('Wrong param \"url\"'), cb, retry);\n    }\n    else {\n      params.url = url;\n    }\n\n    if(options.callback) {\n      params.callback = options.callback;\n    }\n    if(options.omitscript) {\n      params.omitscript = options.omitscript;\n    }\n    if(options.hidecaption) {\n      params.hidecaption = options.hidecaption;\n    }\n    if(options.maxwidth) {\n      params.maxwidth = options.maxwidth;\n    }\n\n    call('GET', '/oembed/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result) {\n        return cb(null, result, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Get a list of realtime subscriptions (see http://instagram.com/developer/realtime/#list-your-subscriptions)\n   * @param  function cb      function (err, result, limit);\n   */\n  subscriptions = function(cb){\n    var retry = function(){\n      subscriptions(cb);\n    };\n\n    call('GET', '/subscriptions/', {}, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Add a subscription on a tag\n   * @param tag string the tag on which to subscribe\n   * @param callback_url string the url on which to be called back\n   * @param options object { verify_token }\n   * @param cb function(err, result)\n   */\n  add_tag_subscription = function(tag, callback_url, options, cb){\n    var retry = function(){\n      add_tag_subscription(tag, callback_url, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    var params = {\n      callback_url: callback_url,\n      object: 'tag',\n      aspect: 'media',\n      object_id: tag\n    };\n\n    if(options.verify_token) {\n      params.verify_token = options.verify_token;\n    }\n\n    call('POST', '/subscriptions/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Subscribe to posts in a geographical circle (see http://instagram.com/developer/realtime/#geography-subscriptions)\n   * @param  {Number}   lat          Latitude of center of circle\n   * @param  {Number}   lng         Longitude of center of circle\n   * @param  {Number}   radius       Radius of circle, in meters\n   * @param  {String}   callback_url URL to be called back when a new post is from this geographical circle\n   * @param  {Object}   options { verify_token }\n   * @param  {Function} cb           function (err, result, limit);\n   */\n  add_geography_subscription = function(lat, lng, radius, callback_url, options, cb){\n    var retry = function(){\n      add_geography_subscription(lat, lng, radius, callback_url, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    var params = {\n      callback_url: callback_url,\n      object:'geography',\n      lat: lat,\n      lng: lng,\n      radius: radius,\n      aspect: 'media'\n    };\n\n    if(options.verify_token) {\n      params.verify_token = options.verify_token;\n    }\n\n    call('POST', '/subscriptions/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Subscribe to posts from your subscribed users (see http://instagram.com/developer/realtime/#user-subscriptions)\n   * @param  {String}   callback_url URL to be called back when a new post is from this user\n   * @param  {Object}   options { verify_token }\n   * @param  {Function} cb           function (err, result, limit);\n   */\n  add_user_subscription = function(callback_url, options, cb){\n    var retry = function(){\n      add_user_subscription(callback_url, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    var params = {\n      callback_url: callback_url,\n      object:'user',\n      aspect: 'media'\n    };\n\n    if(options.verify_token) {\n      params.verify_token = options.verify_token;\n    }\n\n    call('POST', '/subscriptions/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n\n  /**\n   * Subscribe to posts from a specific location (see http://instagram.com/developer/realtime/#location-subscriptions)\n   * @param  {Number}   location_id  a specific Instagram location\n   * @param  {String}   callback_url URL to be called back when a new post is in this location\n   * @param  {Function} cb           function (err, result, limit);\n   */\n  add_location_subscription = function(location_id, callback_url, options, cb){\n    var retry = function(){\n      add_location_subscription(location_id, callback_url, options, cb);\n    };\n\n    if(!cb && typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    var params = {\n      callback_url: callback_url,\n      object:'location',\n      object_id: location_id,\n      aspect: 'media'\n    };\n\n    if(options.verify_token) {\n      params.verify_token = options.verify_token;\n    }\n\n    call('POST', '/subscriptions/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  /**\n   * Delete a realtime subscription\n   * @param  {Object}   options search (see http://instagram.com/developer/realtime/#delete-subscriptions)\n   * @param  {Function} cb      function (err, result, limit);\n   */\n  del_subscription = function(options, cb){\n    var retry = function(){\n      del_subscription(options, cb);\n    };\n\n    var params = {};\n    if(options.id) {\n      params.id = options.id;\n    }\n    if(options.all) {\n      params.object = 'all';\n    }\n\n    call('DELETE', '/subscriptions/', params, function(err, result, remaining, limit) {\n      if(err) {\n        return handle_error(err, cb, retry);\n      } else if(result && result.meta && result.meta.code === 200) {\n        return cb(null, result.data, remaining, limit);\n      } else {\n        return handle_error(result, cb, retry);\n      }\n    }, retry);\n  };\n\n  fwk.method(that, 'use', use, _super);\n\n  fwk.method(that, 'user', user, _super);\n  fwk.method(that, 'user_self_feed', user_self_feed, _super);\n  fwk.method(that, 'user_media_recent', user_media_recent, _super);\n  fwk.method(that, 'user_self_media_recent', user_self_media_recent, _super);\n  fwk.method(that, 'user_self_liked', user_self_liked, _super);\n  fwk.method(that, 'user_search', user_search, _super);\n\n  fwk.method(that, 'user_follows', user_follows, _super);\n  fwk.method(that, 'user_followers', user_followers, _super);\n  fwk.method(that, 'user_self_requested_by', user_self_requested_by, _super);\n  fwk.method(that, 'user_relationship', user_relationship, _super);\n  fwk.method(that, 'set_user_relationship', set_user_relationship, _super);\n\n  fwk.method(that, 'media', media, _super);\n  fwk.method(that, 'media_shortcode', media_shortcode, _super);\n  fwk.method(that, 'media_search', media_search, _super);\n  fwk.method(that, 'media_popular', media_popular, _super);\n\n  fwk.method(that, 'comments', comments, _super);\n  fwk.method(that, 'add_comment', add_comment, _super);\n  fwk.method(that, 'del_comment', del_comment, _super);\n\n  fwk.method(that, 'likes', likes, _super);\n  fwk.method(that, 'add_like', add_like, _super);\n  fwk.method(that, 'del_like', del_like, _super);\n\n  fwk.method(that, 'tag', tag, _super);\n  fwk.method(that, 'tag_media_recent', tag_media_recent, _super);\n  fwk.method(that, 'tag_search', tag_search, _super);\n\n  fwk.method(that, 'location', location, _super);\n  fwk.method(that, 'location_media_recent', location_media_recent, _super);\n  fwk.method(that, 'location_search', location_search, _super);\n\n  fwk.method(that, 'geography_media_recent', geography_media_recent, _super);\n\n  fwk.method(that, 'get_authorization_url', get_authorization_url, _super);\n  fwk.method(that, 'authorize_user', authorize_user, _super);\n\n  fwk.method(that, 'oembed', oembed, _super);\n\n  fwk.method(that, 'subscriptions', subscriptions, _super);\n  fwk.method(that, 'del_subscription', del_subscription, _super);\n  fwk.method(that, 'add_tag_subscription', add_tag_subscription, _super);\n  fwk.method(that, 'add_geography_subscription', add_geography_subscription, _super);\n  fwk.method(that, 'add_user_subscription', add_user_subscription, _super);\n  fwk.method(that, 'add_location_subscription', add_location_subscription, _super);\n\n  fwk.getter(that, 'limit', my, 'limit');\n  fwk.getter(that, 'remaining', my, 'remaining');\n\n  return that;\n};\n\nexports.instagram = instagram;\n"}